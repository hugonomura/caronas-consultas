{"name":"Consulta Simples e Múltipla usando JSP","tagline":"Realizando consultas com JSP","body":"## Consultas\r\nNesse tutorial, iremos implementar dois diferentes tipos de consulta.  \r\n  \r\n* *Consulta Simples* - consiste em realizar uma consulta que retornará um único objeto como resposta.  \r\n* *Consulta Múltipla* - consiste em realizar uma consulta que retornará uma lista de objetos como resposta.  \r\n  \r\n--\r\n##Alterando o banco\r\nComo só tínhamos alguns atributos na nossa tabela `usuario`, temos que realizar algumas alterações para realizar as consultas que gostaríamos.  \r\nPara isso, devemos executar o seguinte código SQL.  \r\n  \r\n     ALTER TABLE disciplinabd.dbo.usuario ADD cidade varchar(30);\r\n     ALTER TABLE disciplinabd.dbo.usuario ADD sexo varchar(10);\r\n  \r\nLembrando que `usuario`, deve ser substituído pelo nome da tabela criada no tutorial anterior.  \r\n  \r\n--\r\n## Inicializando\r\nPara garantir que todos irão ter a mesma versão do projeto, baixe o modelo inicial do projeto, disponível em:  \r\nhttps://github.com/hugonomura/caronas-consultas/archive/master.zip  \r\n  \r\nExtraia os arquivos em uma pasta de sua preferência.  \r\nAbra o Netbeans, clique no menu `Arquivo` > `Abrir Projeto`, navegando até a pasta onde o arquivo foi extraído e clicando em `Abrir Projeto`.  \r\n  \r\n--\r\n## Lembrete\r\nDentro do pacote **persistence** existe a classe `ConnectionCaronasFactory`, não se esqueça de colocar o seu `usuario` e `senha` para acessar o banco de dados, caso contrário, não será possível conectar no banco de dados.  \r\n  \r\n--\r\n## A consulta simples\r\nJá implementamos a funcionalidade de login sem utilizar o banco de dados, agora iremos realmente implementar a funcionalidade e com acesso ao banco de dados.  \r\nA consulta simples efetivamente, será implementada dentro da nossa classe `UsuarioDAO', que também está dentro do pacote `persistence`.  \r\nA assinatura do nosso método será:  \r\n  \r\n      public Usuario consultaSimples(String username) throws SQLException\r\n  \r\nOu seja, dado um nome de usuário (elemento que é único na nossa tabela usuário), iremos retornar um **Usuario**, ou **null**, caso não ele não exista. Note que precisamos lançar uma exceção do tipo `SQLException`, caso algo de errado.  \r\nContinua quase tudo igual ao caso de inserir elementos no banco de dados, exceto o fato de termos que ter uma instância de `Usuario` e usarmos alguns métodos diferentes, conforme o código abaixo.  \r\n  \r\n        Usuario u;\r\n        PreparedStatement ps;\r\n        ResultSet rs;\r\n        String SQL = \"SELECT * FROM disciplinabd.dbo.usuario \"\r\n                + \"WHERE username = '\" + username +  \"'\";\r\n        ps = conn.prepareStatement(SQL);\r\n  \r\nComo é possível ver acima, declaramos uma instância de `Usuario` e o resto é bem parecido com o que executamos na inserção. Note que também temos uma instância de `ResultSet` agora, pois é o que nossa consulta irá retornar.  \r\nPara, efetivamente rodar a consulta, iremos usar outro método agora também, o método `executeQuery`, que irá retornar uma instância de `ResultSet`.  \r\n  \r\n        rs = ps.executeQuery();  \r\n  \r\nAgora, para recuperar o primeiro elemento da busca, temos que mover nosso ponteiro para a próxima linha do resultado, sendo que, nesse caso, caso haja alguma linha depois, significa que a busca retornou um objeto e, caso contrário, o usuário não foi encontrando.  \r\nFazemos isso da seguinte forma:  \r\n  \r\n        if(rs.next()){\r\n            u = new Usuario();\r\n            u.setUsuario(rs.getString(\"username\"));\r\n            u.setEmail(rs.getString(\"email\"));\r\n            u.setSenha(rs.getString(\"senha\"));\r\n            u.setTipo(rs.getString(\"tipo\"));\r\n        }else{\r\n            u = null;\r\n        }\r\n  \r\nNote que, tivemos que recuperar cada atributo de `Usuario`, passando como parâmetro o nome da coluna no banco de dados.  \r\nPor fim, basta retornarmos o usuário que foi instanciado (ou `null`, caso não haja resultado).  \r\n  \r\n        return u;\r\n  \r\n--\r\n## EfetuaLogin\r\nAgora, temos que modificar o **controle** `EfetuaLogin`.  \r\nComo iremos mexer com o **DAO** `UsuarioDAO`, precisamos realizar o devido import.  \r\n  \r\n         import persistence.UsuarioDAO;\r\n  \r\nCom isso feito, já podemos modificar o método `doPost` com a verificação que queremos.  \r\nPrimeiramente precisamos declarar um novo **DAO** e realizar a recuperação do usuário.  \r\n  \r\n        UsuarioDAO userDao = new UsuarioDAO();\r\n        Usuario u = userDao.consultaSimples(login);\r\n  \r\nAgora, iremos tratar o usuário retornado pelo banco de dados, sendo que, se a senha informada pelo usuário, for igual a senha do usuário no banco de dados, a página `viewLogado` deve ser carregada e, caso contrário, a `index` deve ser mostrada novamente.  \r\n  \r\n        if (senha.equals(u.getSenha())) {\r\n            // vincula bean\r\n            request.setAttribute(\"usuarioBean\", u);\r\n\r\n            RequestDispatcher rd = null;\r\n            rd = request.getRequestDispatcher(\"/viewLogado.jsp\");\r\n            rd.forward(request, response);\r\n        }\r\n        response.sendRedirect(\"index.jsp\");\r\n  \r\nComo existem diversas exceções que são lançadas, tanto pelo **DAO**, quanto pelo **Factory**, devemos tratar essas exceções no controle, deixando o código da seguinte forma:  \r\n  \r\n       try {\r\n        String login = request.getParameter(\"login\");\r\n        String senha = request.getParameter(\"senha\");\r\n\r\n        UsuarioDAO userDao = new UsuarioDAO();\r\n        Usuario u = userDao.consultaSimples(login);\r\n        if (senha.equals(u.getSenha())) {\r\n            // vincula bean\r\n            request.setAttribute(\"usuarioBean\", u);\r\n\r\n            RequestDispatcher rd = null;\r\n            rd = request.getRequestDispatcher(\"/viewLogado.jsp\");\r\n            rd.forward(request, response);\r\n        }\r\n        response.sendRedirect(\"index.jsp\");\r\n    } catch (SQLException ex) {\r\n        Logger.getLogger(EfetuaLogin.class.getName()).log(Level.SEVERE, null, ex);\r\n        throw new ServletException(ex.getMessage());\r\n    } catch (CaronasDAOException ex) {\r\n        Logger.getLogger(EfetuaLogin.class.getName()).log(Level.SEVERE, null, ex);\r\n        throw new ServerException(ex.getMessage());\r\n    }\r\n  \r\n--\r\n## A consulta múltipla\r\nIremos implementar a consulta múltipla dentro da classe **UsuarioDAO**.  \r\nPara isso, precisamos novamente criar o método com a assinatura semelhante ao da consulta simples, apenas mudando o tipo de retorno para uma lista de `Usuario` e o argumento recebido será o nome de uma **cidade** agora, deixando a assinatura da seguinte forma:  \r\n  \r\n    public List<Usuario> consultaMultipla(String cidade) throws SQLException\r\n  \r\nComo iremos usar **List**, também devemos realizar o devido **import** no inicio da classe.  \r\n  \r\n     import java.util.List;\r\n  \r\nA requisição dos usuários de uma cidade é feita da mesma forma que a recuperação de um único usuário, o que irá mudar é a forma como iremos tratar a requisição.  \r\n  \r\n        List<Usuario> listaUsuarios = new ArrayList<Usuario>();\r\n        PreparedStatement ps;\r\n        ResultSet rs;\r\n        String SQL = \"SELECT * FROM disciplinabd.dbo.usuario \"\r\n                + \"WHERE cidade = '\" + cidade +  \"'\";\r\n        ps = conn.prepareStatement(SQL);\r\n        \r\n        rs = ps.executeQuery();\r\n  \r\nAgora que já temos o retorno da consulta na instância de rs e, como esse retorno pode conter vários usuários, teremos que substitui ir o **if** que estávamos utilizando na **consulta simples**, por um **while** e adicionando uma nova instância de `Usuario` a cada iteração, deixando o código da seguinte forma:  \r\n  \r\n        while(rs.next()){\r\n            Usuario u = new Usuario();\r\n            u.setUsuario(rs.getString(\"username\"));\r\n            u.setEmail(rs.getString(\"email\"));\r\n            u.setSenha(rs.getString(\"senha\"));\r\n            u.setTipo(rs.getString(\"tipo\"));\r\n            u.setCidade(rs.getString(\"cidade\"));\r\n            u.setSexo(rs.getString(\"sexo\"));\r\n            listaUsuarios.add(u);\r\n        }\r\n  \r\nAssim, a implementação do método `consultaMultipla` fica da seguinte forma:  \r\n  \r\n    public List<Usuario> consultaMultipla(String cidade) throws SQLException{\r\n        List<Usuario> listaUsuarios = new ArrayList<Usuario>();\r\n        PreparedStatement ps;\r\n        ResultSet rs;\r\n        String SQL = \"SELECT * FROM disciplinabd.dbo.usuario \"\r\n                + \"WHERE cidade = '\" + cidade +  \"'\";\r\n        ps = conn.prepareStatement(SQL);\r\n        \r\n        rs = ps.executeQuery();\r\n        while(rs.next()){\r\n            Usuario u = new Usuario();\r\n            u.setUsuario(rs.getString(\"username\"));\r\n            u.setEmail(rs.getString(\"email\"));\r\n            u.setSenha(rs.getString(\"senha\"));\r\n            u.setTipo(rs.getString(\"tipo\"));\r\n            u.setCidade(rs.getString(\"cidade\"));\r\n            u.setSexo(rs.getString(\"sexo\"));\r\n            listaUsuarios.add(u);\r\n        }\r\n        return listaUsuarios;\r\n    }\r\n  \r\n--\r\n## BuscaUsuarios\r\nAgora iremos implementar o método no **controle** `BuscaUsuarios` que recupera o nome de uma cidade de uma view, realiza a recuperação por meio do **DAO** e mostra o resultado em outra view.  \r\nComo a página que realiza a requisição (**buscaPorCidade.jsp**), envia os dados utilizando **get**, iremos realizar a nossa implementação dentro do método **doGet**.  \r\nNão existem grandes diferenças entre a consulta simples e a múltipla, novamente, a única diferença é ter que alterar o `Usuario` que era retornado por uma `List<Usuario`, registrando essa lista para ser recuperada na view (no caso a view `resultadoBusca.jsp`).  \r\n  \r\n            UsuarioDAO uDAO = new UsuarioDAO();\r\n            List<Usuario> listaUsuarios;\r\n            \r\n            String cidade = request.getParameter(\"nomeCidade\");\r\n            listaUsuarios = uDAO.consultaMultipla(cidade);\r\n            request.setAttribute(\"listaUsuarios\", listaUsuarios);\r\n            \r\n            RequestDispatcher rd = null;\r\n            rd = request.getRequestDispatcher(\"/resultadoBusca.jsp\");\r\n            rd.forward(request, response);\r\n  \r\nNovamente, teremos que tratar as **exceptions** lançadas por UserDAO, deixando a implementação do `doGet` da seguinte forma:  \r\n  \r\n        try {\r\n            UsuarioDAO uDAO = new UsuarioDAO();\r\n            List<Usuario> listaUsuarios;\r\n            \r\n            String cidade = request.getParameter(\"nomeCidade\");\r\n            listaUsuarios = uDAO.consultaMultipla(cidade);\r\n            request.setAttribute(\"listaUsuarios\", listaUsuarios);\r\n            \r\n            RequestDispatcher rd = null;\r\n            rd = request.getRequestDispatcher(\"/resultadoBusca.jsp\");\r\n            rd.forward(request, response);\r\n        } catch (CaronasDAOException ex) {\r\n            Logger.getLogger(BuscaUsuarios.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new ServletException(ex.getMessage());\r\n        } catch (SQLException ex) {\r\n            Logger.getLogger(BuscaUsuarios.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new ServletException(ex.getMessage());\r\n        }\r\n  \r\n## resultadoBusca.jsp\r\nAgora só nos resta fazer a recuperação dos dados na nossa view.  \r\nPara isso, devemos mexer na nossa view `resultadoBusca.jsp`.  \r\n  \r\nComo iremos recuperar uma lista de usuários, precisamos dos devidos imports na view, ou seja, precisamos adicionar os seguintes imports no inicio do arquivo.  \r\n  \r\n        <%@page import=\"java.util.List\"%>\r\n        <%@page import=\"model.Usuario\"%>\r\n  \r\nNossa recuperação dos usuários deverá ser feita dentro do **article** chamado `form`, conforme a indicação abaixo:  \r\n  \r\n        <section class=\"container\">\r\n          <article id=\"form\">\r\n            <header>\r\n                <h1>Resultado da busca por: <%= request.getParameter(\"nomeCidade\") %></h1>\r\n            </header>\r\n                --> AQUI IRÃO AS IMPLEMENTAÇÕES <--\r\n          </article>\r\n  \r\nComo iremos utilizar código Java, precisamos utilizar os scriplets **<% %>**.\r\nO que queremos fazer agora é recuperar a `listaUsuarios` que registramos em nosso controle, iterar mostrando os elementos, no caso da lista possuir elemento(s), ou mostrar que não existem usuários com cadastro nessa cidade, caso contrário.  \r\nComo o atributo será recuperado como um **Object**, iremos precisar de um **cast**, deixando nosso código da seguinte forma:  \r\n  \r\n                    List<Usuario> usuarios = (List<Usuario>)request.getAttribute(\"listaUsuarios\");\r\n  \r\nAssim, já temos nossa lista de usuários retornada, sendo que agora só precisamos fazer a verificação se a lista é vazia ou não e mostrar os usuários (no caso de existirem), deixando o código (com a recuperação) da seguinte forma:  \r\n  \r\n                <%\r\n                    List<Usuario> usuarios = (List<Usuario>)request.getAttribute(\"listaUsuarios\");\r\n                    if(usuarios.isEmpty()){\r\n                    %>\r\n                        Não foram encontrados usuários cadastrados nessa cidade. :(\r\n                    <% }else{ %>\r\n                    <table>\r\n                        <thead>\r\n                        <th width=\"180\">Email</th>\r\n                        <th width=\"200\">Nome usuario</th>\r\n                        <th width=\"100\">Sexo</th>\r\n                        </thead>\r\n                    <%\r\n                    for(Usuario u:usuarios){\r\n                        out.println(\"<tr>\" + \r\n                                \"<td>\" + u.getEmail()+ \"</td>\" + \r\n                                \"<td>\" + u.getUsuario() + \"</td>\" + \r\n                                \"<td>\" + u.getSexo()+ \"</td>\" + \r\n                                \"<tr>\");\r\n                    }\r\n                   %>\r\n                    </table>\r\n                    <% } %>\r\n  ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}